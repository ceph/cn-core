/*
 * Ceph Nano Core (C) 2019 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Below main package has canonical imports for 'go get' and 'go build'
 * to work with all other clones of github.com/ceph/cn repository. For
 * more information refer https://golang.org/doc/go1.4#canonicalimports
 */

package cmd

import (
	"bufio"
	"crypto/rand"
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/alecthomas/units"
	"github.com/gofrs/uuid"
)

func generateSecret() string {
	// Declare our variable-sized buffer of bytes of 28 bytes
	// Header is 12 bytes and the random key part is 16 bytes
	var buffer [12 + 16]byte

	// Assume LittleEndian for Byte Order, this then assumes x86 system
	// Note from https://docs.python.org/2/library/struct.html#byte-order-size-and-alignment
	// Native byte order is big-endian or little-endian, depending on the host system.
	// For example, Intel x86 and AMD64 (x86-64) are little-endian; Motorola 68000 and PowerPC G5 are big-endian;
	// ARM and Intel Itanium feature switchable endianness (bi-endian).

	// Add 1 to the first 2 bytes
	binary.LittleEndian.PutUint16(buffer[0:2], 1)

	// Add the current elapsed time since 1970 in sec
	binary.LittleEndian.PutUint32(buffer[2:6], uint32(time.Now().Unix()))

	// Add 0
	binary.LittleEndian.PutUint32(buffer[6:10], 0)

	// Add the length of the random generated bytes
	binary.LittleEndian.PutUint16(buffer[10:12], 16)

	// Generates random bytes
	if _, err := rand.Read(buffer[12:28]); err != nil {
		log.Fatal(err)
	}

	return base64.StdEncoding.EncodeToString(buffer[:])
}

func generateUUID() string {
	uuid, err := uuid.NewV4()
	if err != nil {
		log.Fatalf("failed to generate UUID: %v", err)
	}

	return uuid.String()
}

func generateCephConf(hostname, rgwEngine, rgwPort string) (string, string) {
	fsid := generateUUID()
	return fmt.Sprintf(cephConfTemplate, fsid), fsid
}

func writeCephConf(hostname, cephConfFilePath string) string {
	log.Println("init mon: writing ceph configuration file")

	cephConf, fsid := generateCephConf(hostname, rgwEngine, rgwPort)
	cephConfBytes := []byte(cephConf)

	err := ioutil.WriteFile(cephConfFilePath, cephConfBytes, 0644)
	if err != nil {
		log.Fatal(err)
	}

	return fsid
}

// Thanks https://stackoverflow.com/questions/33161284/recursively-create-a-directory-with-a-certain-owner-and-group
func chownR(path string, uid, gid int) error {
	return filepath.Walk(path, func(name string, info os.FileInfo, err error) error {
		if err == nil {
			err = os.Chown(name, uid, gid)
		}
		return err
	})
}

func getAwsKeys() (string, string) {
	jsonFile, err := os.Open(cnUserDetailsFile)
	if err != nil {
		fmt.Println(err)
	}
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)

	// declare structures for json
	type s3Details []struct {
		AccessKey string `json:"Access_key"`
		SecretKey string `json:"Secret_key"`
	}
	type jason struct {
		Keys s3Details
	}
	// assign variable to our json struct
	var parsedMap jason

	json.Unmarshal(byteValue, &parsedMap)

	cnAccessKey := parsedMap.Keys[0].AccessKey
	cnSecretKey := parsedMap.Keys[0].SecretKey

	return cnAccessKey, cnSecretKey
}

func fetchAdminKeyring(monKeyringPath string) ([]byte, []string, error) {
	log.Println("init mgr: fetching admin keyring")

	cmd := exec.Command("ceph", "-n", "mon.", "-k", monKeyringPath, "auth", "get-or-create", "client.admin", "-o", adminKeyringPath)
	out, err := cmd.CombinedOutput()
	return out, cmd.Args, err
}

func sedFile(path, old, new string) {
	read, err := ioutil.ReadFile(path)
	if err != nil {
		panic(err)
	}

	newContents := strings.Replace(string(read), old, new, -1)

	err = ioutil.WriteFile(path, []byte(newContents), 0)
	if err != nil {
		log.Fatal(err)
	}
}

func configureClients(client string, arg ...string) {
	cnAccessKey, cnSecretKey := getAwsKeys()

	switch client {
	case "s3cmd":
		log.Println("init rgw: configure s3cmd client")
		sedFile(s3CmdFilePath, "AWS_ACCESS_KEY_PLACEHOLDER", cnAccessKey)
		sedFile(s3CmdFilePath, "AWS_SECRET_KEY_PLACEHOLDER", cnSecretKey)
		sedFile(s3CmdFilePath, "localhost", arg[0]) // this is always one arg, not sure why making the string default makes it a slice...

	case "dashboard":
		// Read ENV and search for a value for dashExposedIP
		dashExposedIPEnv := os.Getenv("EXPOSED_IP")
		if len(dashExposedIPEnv) > 0 {
			dashExposedIP = dashExposedIPEnv
		}

		log.Println("init dashboard: configure dashboard")
		path := dashboardDir + "static/js/base.js"
		sedFile(path, "ENDPOINT", "http://"+dashExposedIP+":"+rgwPort)
		sedFile(path, "ACCESS_KEY", cnAccessKey)
		sedFile(path, "SECRET_KEY", cnSecretKey)

		err := os.Link(dashboardDir+"sree.cfg.sample", dashboardDir+"sree.cfg")
		if err != nil {
			log.Fatal(err)
		}
		path = dashboardDir + "sree.cfg"
		sedFile(path, "RGW_CIVETWEB_PORT_VALUE", rgwPort)
		sedFile(path, "SREE_PORT_VALUE", dashPort)
	}

}

func cephHealth() error {
	// A WaitGroup waits for a collection of goroutines to finish.
	// This is useful for us since we are collecting both stderr and stdout
	// We have to be able to tell if one of two failed
	// This is for error handling purpose
	// Inspiration from https://github.com/boz/ephemerald/blob/master/lifecycle/action_exec.go#L130-L163
	var wg sync.WaitGroup

	log.Println("init: running ceph health watcher")

	// declare command to execute
	cmd := exec.Command("ceph", "-w")

	// get an io reader for stdout
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return err
	}

	// get an io reader for stderr
	stderr, err := cmd.StderrPipe()
	if err != nil {
		return err
	}

	// start the command
	if err := cmd.Start(); err != nil {
		return err
	}

	// Add 2 waiters since we have two goroutine
	wg.Add(2)

	// Go routine that reads stdout
	go func() {
		defer wg.Done()
		readPipe(stdout)
	}()

	// Go routine that reads stderr
	go func() {
		defer wg.Done()
		readPipe(stderr)
	}()

	// Wait for both waiters to complete
	// If stdout succeeds this means waiting 'forever'
	wg.Wait()

	if err := cmd.Wait(); err != nil {
		return err
	}

	return nil
}

func readPipe(reader io.Reader) {
	r := bufio.NewReader(reader)

	for true {
		line, _, _ := r.ReadLine()
		if line != nil {
			outStr := string(line)
			fmt.Println(outStr)
		} else {
			// this means EOF and we stop the iteration
			// this likely means the 'ceph -w' died
			break
		}
	}
}

func getMemLimit() int {
	memLimit, err := ioutil.ReadFile("/sys/fs/cgroup/memory/memory.limit_in_bytes")
	if err != nil {
		log.Fatal(err)
	}

	// we need to trim the newline since the string representation of the Readfile gives
	// "209715200\n" and strconv.Atoi is not happy
	memLimitInt, err := strconv.Atoi(strings.TrimSpace((string(memLimit))))
	if err != nil {
		log.Fatal(err)
	}

	return memLimitInt
}

func getAvailableRAM() uint64 {
	memLimitInt := getMemLimit()

	memInfo, err := ioutil.ReadFile("/proc/meminfo")
	if err != nil {
		log.Fatal(err)
	}

	// 8 ExaBytes is the value of an unbounded device
	if memLimitInt == 9223372036854771712 {
		// Looks like the container doesn't have any memory limit
		// Let's report the MemAvailable on this system
		pattern := regexp.MustCompile("MemAvailable: *[0-9]{1,}")
		s := pattern.FindString(string(memInfo))
		m := strings.TrimSpace(strings.Split(s, ":")[1])

		mem, err := strconv.Atoi(m)
		if err != nil {
			log.Fatal(err)
		}

		return (uint64(mem) * uint64(1024))
	}

	currentUsage, err := ioutil.ReadFile("/sys/fs/cgroup/memory/memory.usage_in_bytes")
	if err != nil {
		log.Fatal(err)
	}

	currentUsageInt, err := strconv.Atoi(strings.TrimSpace((string(currentUsage))))
	if err != nil {
		log.Fatal(err)
	}

	a := memLimitInt - currentUsageInt

	return uint64(a)
}

func bToMb(b uint64) uint64 {
	return b / 1024 / 1024
}

func mbTob(b uint64) uint64 {
	return b * 1024 * 1024
}

func tuneMemory(memAvailable uint64) (osdMemoryTarget uint64, osdMemoryBase uint64, osdMemoryCacheMin uint64) {
	_50mB := mbTob(50)
	_128mB := mbTob(128)
	_4096mB := mbTob(4096)

	log.Printf("init osd: found %dMB of RAM available.\n", bToMb(memAvailable))

	if memAvailable > _4096mB {
		log.Println("init osd: more than 4GB of RAM is available. Caping OSD memory usage to 4GB.")
		memAvailable = _4096mB
	}

	osdMemoryTarget = memAvailable - _50mB
	if osdMemoryTarget < _128mB {
		log.Fatalf("init osd: something strange is going on, I should have enough memory but osd_memory_target is too small: %dMB, cannot tune.\n", bToMb(osdMemoryTarget))
	}

	osdMemoryBase = memAvailable / 2
	if osdMemoryBase < _128mB {
		log.Fatalf("init osd: something strange is going on, I should have enough memory but  osd_memory_base is too small: %dMB, cannot tune.\n", bToMb(osdMemoryBase))
	}

	osdMemoryCacheMin = ((osdMemoryTarget-osdMemoryBase)/2 + osdMemoryBase)
	log.Printf("init osd: tuning osd memory consumption with osd_memory_target: %dMB, osd_memory_base: %dMB and osd_memory_cache_min: %dMB.\n", bToMb(osdMemoryTarget), bToMb(osdMemoryBase), bToMb(osdMemoryCacheMin))

	return osdMemoryTarget, osdMemoryBase, osdMemoryCacheMin
}

func validateAvaibleMemory(cnMemMin uint64, memLimit int) error {
	cnMemMinB := mbTob(cnMemMin)

	if uint64(memLimit) < cnMemMinB {
		return errors.New("init: run me with at least 512mb of ram")
	}

	return nil
}

func toBytes(value string) int64 {
	var bytes units.Base2Bytes
	var err error
	bytes, err = units.ParseBase2Bytes(value)
	if err != nil {
		log.Fatal(err)
	}
	return int64(bytes)
}

// getFileType checks wether a specified data is directory, a block device or something else
// function borrowed from https://github.com/andrewsykim/kubernetes/blob/2deb7af9b248a7ddc00e61fcd08aa9ea8d2d09cc/pkg/util/mount/mount_linux.go#L416
func getFileType(pathname string) (string, error) {
	finfo, err := os.Stat(pathname)
	if os.IsNotExist(err) {
		return "notfound", fmt.Errorf("path %q does not exist", pathname)
	}
	// err in call to os.Stat
	if err != nil {
		return "error", err
	}

	mode := finfo.Sys().(*syscall.Stat_t).Mode
	switch mode & syscall.S_IFMT {
	case syscall.S_IFSOCK:
		return "socket", nil
	case syscall.S_IFBLK:
		return "blockdev", nil
	case syscall.S_IFCHR:
		return "chardev", nil
	case syscall.S_IFDIR:
		return "directory", nil
	case syscall.S_IFREG:
		return "file", nil
	}

	return "error", fmt.Errorf("only recognize file, directory, socket, block device and character device")
}

func freeDiskSpace(path string) (free uint64, err error) {
	s := syscall.Statfs_t{}
	if err := syscall.Statfs(path, &s); err != nil {
		return 0, err
	}
	free = uint64(s.Bsize) * s.Bavail
	return free, nil
}

func bToGb(b uint64) uint64 {
	return b / 1024 / 1024 / 1024
}

func validateAvailableBluestoreSize(bluestoreSizeMin uint64, path string) error {
	// fetch the available space provided
	free, err := freeDiskSpace(path)
	if err != nil {
		log.Fatalf("init: %s %s", err, path)
	}
	// available space must be greater than default bluestore block size
	if free < bluestoreSizeMin {
		return fmt.Errorf("init: Failed to bootstrap, need a minimum of %dGb space for BlueStore, but available free space is %dGb", bToGb(bluestoreSizeMin), bToGb(free))
	}
	return nil
}
